<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java 8 on El Baúl del programador</title>
    <link>https://elbauldelprogramador.com/tags/java-8/index.xml</link>
    <description>Recent content in Java 8 on El Baúl del programador</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>es-ES</language>
    <atom:link href="https://elbauldelprogramador.com/tags/java-8/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>5 Razones para estar entusiasmados con Java en el 2013</title>
      <link>https://elbauldelprogramador.com/5-razones-para-estar-entusiasmados-con-java-en-el-2013/</link>
      <pubDate>Mon, 12 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://elbauldelprogramador.com/5-razones-para-estar-entusiasmados-con-java-en-el-2013/</guid>
      <description>&lt;p&gt;&lt;amp-img on=&#34;tap:lightbox1&#34; role=&#34;button&#34; tabindex=&#34;0&#34; layout=&#34;responsive&#34; src=&#34;https://elbauldelprogramador.com/img/2012/12/java1-300x227.jpg&#34; alt=&#34;java&#34; width=&#34;300px&#34; height=&#34;227px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Habiendo terminado el 2012, es tiempo de mirar hacia los próximos 12 meses en el mundo del desarrollo. Luego de leer &lt;a href=&#34;http://jaxenter.com/what-will-2013-bring-developers-place-their-bets-45933.html&#34; target=&#34;_blank&#34;&gt;este interesante artículo&lt;/a&gt; sobre las predicciones de algunos respetados desarrolladores, presentamos cinco sencillas razones por las cuales debes entusiasmarte con lo que traerá el 2013&amp;#8230;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. Java 8&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Un tema obvio para comenzar para la mayoría de los desarrolladores Java, es la &lt;em&gt;release&lt;/em&gt; del 2013. Asumiendo que no habrá demoras, podemos esperar que Java 8 llegue en Septiembre, trayendo consigo muchas funciones lambda esperadas.&lt;/p&gt;

&lt;p&gt;Es bastante probable que en el período inmediatamente siguiente a la salida de Java 8, veamos publicaciones en blogs tanto sobre quejas por la complejidad de las nuevas características como porque estas mismas no son lo suficientemente importantes como para justificar su interés.&lt;/p&gt;

&lt;p&gt;&lt;!--ad--&gt;&lt;/p&gt;

&lt;p&gt;De cualquier manera, algunas características muy necesarias que estaban demoradas finalmente aparecen y tendremos que ponernos a trabajar en serio. La mejorada API de Date and Time en Java 8 también merece una mención.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. Los lenguajes de la JVM van un paso adelante&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;El 2012 fue realmente el año en que los lenguajes para la JVM tomaron un papel principal. Liderando el grupo se econtró el multi-paradigma Scala, cosechando &lt;a href=&#34;http://www.scala-lang.org/node/1658&#34; target=&#34;_blank&#34;&gt;impresionantes clientes empresariales&lt;/a&gt; gracias a la inversión en Typesafe. Extendiendo las posibilidades con Akka y Play 2.0!, parece ser que las fundaciones están focalizadas en avanzar más en el 2013. El desafío real es vender Scala a todos aquellos que no necesiten algo pesado.&lt;/p&gt;

&lt;p&gt;Dynamic Groovy no se quedó atrás el año pasado, agregando compilación estática en el mix con Groovy 2.0. Una versión principal se espera poco después de Java 8 para que los desarrolladores Groovy puedan aprovechar al máximo las nuevas características. El equipo de soporte, incluyendo Gradle y Grails, podría ser un gran atractivo para aquellos que buscan una alternativa a Java que no se aleje demasiado.&lt;/p&gt;

&lt;p&gt;No hemos mencionado las bondades de Clojure, JRuby y &lt;a href=&#34;http://kotlin.jetbrains.org/&#34; target=&#34;_blank&#34;&gt;Kotlin&lt;/a&gt;; este último con mucho trabajo ya que está cercano a su versión final. En última instancia, el éxito se reduce a una comunidad activa, la cual muchos lenguajes de la JVM se han percatado, y los proyectos derivados de esa comunidad.&lt;/p&gt;

&lt;p&gt;Si el 2012 fue el despegue, el 2013 es la consolidación en los círculos empresariales, lo cual es un incentivo para que los desarrolladores utilicen el lenguaje.&lt;/p&gt;

&lt;p&gt;**3.  La importancia &lt;strong&gt;en aumento &lt;/strong&gt;de JavaScript en Java**&lt;/p&gt;

&lt;p&gt;Los detalles fueron delgados en el terreno de las nuevas iniciativas en OpenJDK para la mayor parte del 2012, pero llegando a fin de año, habíamos aprendido un poco más acerca de los objetivos de cada proyecto y su importancia para la innovación en Java.&lt;/p&gt;

&lt;p&gt;El nuevo set del motor JavaScript a incluir en Java 8 integrará &lt;a href=&#34;http://mail.openjdk.java.net/pipermail/announce/2012-November/000139.html&#34; target=&#34;_blank&#34;&gt;JavaScript dentro de las aplicaciones Java&lt;/a&gt;. El &lt;a href=&#34;http://openjdk.java.net/projects/nashorn/&#34; target=&#34;_blank&#34;&gt;Proyecto Nashorn &lt;/a&gt;cimienta la noción del resurgimiento de Javascript e incluso mayor relevancia para los desarrolladores Java.&lt;/p&gt;

&lt;p&gt;Iniciado en secreto, Nashorn fue liberado en Noviembre y apareció en el repositorio OpenJDK&lt;a href=&#34;https://blogs.oracle.com/nashorn/entry/open_for_business&#34; target=&#34;_blank&#34;&gt; cuatro días antes de Navidad&lt;/a&gt;. Otro gran punto extra para Nashorn es la inclusión crucial del extendidamente popular node.js dentro de lo pactado, marcando el comienzo de un futuro políglota. Con muchos más detalles prometidos, estaremos monitoreando, esta vez, con ojos de águila.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. Sacando más partido de tu inversión - Aprovechando la GPU &lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Otro proyecto en OpenJDK que tiene un gran potencial es &lt;a href=&#34;http://openjdk.java.net/projects/sumatra/&#34; target=&#34;_blank&#34;&gt;Sumatra&lt;/a&gt;, con el objetivo de potenciar un mayor rendimiento de Java utilizando la GPU. Las investigaciones iniciales están focalizadas en la JVM Hotspot para asentar las bases, antes de &amp;#8216;apuntalar&amp;#8217; las librerías de Java 8 y las características propias del lenjuaje como *lambdas *para testear las técnicas que utilizan las últimas vanguardias de Java.&lt;/p&gt;

&lt;p&gt;El proyecto, liderado por un especialista AMD en GPU, espera encontrar algunos obstáculos en el camino con la API de Java y sus construcciones, por lo tanto no veremos las ideas implementadas en Java 8, pero Sumatra puede liderar algunos grandes avances y nuevas técnicas en la línea del desarrollo.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5. Java entra más en profundidad en la nube&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Con docenas de opciones para IaaS y PaaS que inundan el mercado, desde indies como Jelastic y gigantes de la industria como Oracle y AWS, los desarrolladores estan repletos de opciones. Java, al parecer, ha realizado con éxito el salto al nuevo mundo de &amp;#8220;la nube&amp;#8221;.&lt;/p&gt;

&lt;p&gt;El mayor problema del momento, como resalta Martijn Verburg en el blog J&lt;a href=&#34;http://www.javaadvent.com/2012/12/java-2012-review-and-future-predictions.html&#34; target=&#34;_blank&#34;&gt;ava Advent Calendar&lt;/a&gt;, es la falta de estandarización y optimización. Con las características de la nube propias de Java, &lt;a href=&#34;http://jaxenter.com/oracle-pushes-cloud-features-back-to-java-ee-8-44301.html&#34; target=&#34;_blank&#34;&gt;diferidas en Java EE 8&lt;/a&gt;, es ahora cuestión de los proveedores el hecho de facilitar estándares como &lt;a href=&#34;http://jaxenter.com/round-the-campfire-talking-paas-standards-with-oracle-cloudsoft-and-cloudbees-44571.html&#34; target=&#34;_blank&#34;&gt;CAMP&lt;/a&gt; o, en su defecto, a la comunidad para que brinden nuevos frameworks universales como &lt;a href=&#34;http://www.jclouds.org/&#34; target=&#34;_blank&#34;&gt;jclouds&lt;/a&gt;. Mientras tanto, otros se niegan a esperar pacientemente que Oracle provea características como capacidad multiusuario y recolección de basura (&lt;em&gt;garbage collection&lt;/em&gt;) eficiente, como Waratek.*
*&lt;/p&gt;

&lt;p&gt;Con plataformas en la nube convirtiendose rápidamente en la norma, es probable que veamos el lanzamiento de aún más soluciones tercerizadas para soporte de Java en la nube: con Java EE 8 próximamente entre nosotros  (posiblemente 2014), tal vez ni siquiera lo necesitemos. (Elliot Bentley)&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h4 id=&#34;referencias&#34;&gt;Referencias&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;5 Reasons to be excited about Java in 2013&lt;/em&gt; »» &lt;a href=&#34;http://jaxenter.com/5-reasons-to-be-excited-about-java-in-2013-45938.html&#34; target=&#34;_blank&#34;&gt;jaxenter.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Lo que se viene en programación funcional de Java&amp;#8230;</title>
      <link>https://elbauldelprogramador.com/lo-que-se-viene-en-programacion-funcional-de-java/</link>
      <pubDate>Mon, 12 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://elbauldelprogramador.com/lo-que-se-viene-en-programacion-funcional-de-java/</guid>
      <description>&lt;p&gt;Elliott Rusty Harold &lt;a href=&#34;http://cafe.elharo.com/programming/java-programming/why-functional-programming-in-java-is-dangerous/&#34; target=&#34;_blank&#34;&gt;está anunciando en su blog&lt;/a&gt; que la programación funcional en Java es peligrosa. Está equivocado, y ya perdió su turno &amp;#8212; Está viniendo con Java le guste o no.
Un resumen de las razones que menciona en su artículo son:&lt;/p&gt;

&lt;p&gt;&lt;!--ad--&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Java no es un lenguaje de &lt;a href=&#34;http://en.wikipedia.org/wiki/Lazy_evaluation&#34; target=&#34;_blank&#34;&gt;evaluación perezosa&lt;/a&gt;. En Java, los programadores pueden enredarse y terminar generando errores con heap y stack.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;El artículo presenta una implementación simple de código Clojure que al pasarla a lenguaje Java falla en tiempo de ejecución.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A partir de esta idea los programadores pueden lograr cosas muy malas, por ello tendríamos que evitarla.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Y por último, afirma que es &amp;#8220;peligrosamente ineficiente&amp;#8221; en Java/JVM, reconociendo que no tiene referencias para respaldar esta afirmación, y que de algún modo está ignorando si Clojure y Scala corren en la JVM aparentemente sin problemas.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Esos puntos son básicamente un resumen del artículo.&lt;/p&gt;

&lt;p&gt;Mira, como Elliott señala, Java no es Haskell. Ni Lisp. Es su propio lenguaje, basado en una historia imperativa y orientada a objetos, pero no por ello menos apta a incorporar características funcionales dentro de su desarrollo que la aptitud de Lisp para incorporar características de programación orientada a objetos. Sin embargo, si haces sandeces, como intentar regenerar una lista infinita (implícitamente de evaluación perezosa) en Clojure mediante la creación de una lista actualizada que se extiende hasta el infinito&amp;#8230; vas a reventar la JVM. Uh. Ni siquiera el supercomputador en USS Enterprise de dentro de 500 años tendrá la posibilidad de construir esa lista.&lt;/p&gt;

&lt;p&gt;Migrar código de un lenguaje a otro no es un ejercicio trivial. Si intentas migrar línea-a-línea y expresión-por-expresión, puedes esperar que tu código traducido no sea idiomáticamente correcto. (Ya lo se, &lt;a href=&#34;http://blogs.tedneward.com/2012/12/21/Envoy+In+Scala+JavaScript+And+More.aspx&#34;&gt;habiendo hecho la prueba.&lt;/a&gt;) La raiz del problema en el código traducido es doble. Por un lado, (el más necio y poco elegante) simula de muy mala forma cómo debería verse una lista infinita en Java &amp;#8212; un comentador hizo un mejor trabajo mostrando cómo un &lt;strong&gt;Iterator&lt;/strong&gt; puede crearse para realizar la misma tarea que Haskell, de hecho, ya hace produciendo el valor siguiente bajo demanda, en lugar de intentar crear una lista de &lt;strong&gt;Integers&lt;/strong&gt; extendiéndose hasta el infinito. Para alguien que profesa tener experiencia y amor por Haskell, es impactante que Elliott cometa este tipo de error, lo cual genera la impresión de que está intentando crear &lt;a href=&#34;http://es.wikipedia.org/wiki/Falacia_del_hombre_de_paja&#34; target=&#34;_blank&#34;&gt;&lt;em&gt;una falacia del hombre de paja&lt;/em&gt;&lt;/a&gt;. Además asume que cualquiera que programe en Java funcionalmente tendrá que crear todas sus herramientas funcionales a mano, y honestamente, usando Guava o FJ en este caso haría este código ejemplo MUCHO más facil de digerir. El hecho de que ignore ambas en su falacia nuevamente reafirma la idea de que está deliberadamente tergiversando ideas para mostrar su punto.*
*&lt;/p&gt;

&lt;p&gt;Su cuestión subyacente parece ser simple: &amp;#8220;Trabajo con malos programadores, que no parecen entender cómo escribir código funcional en Java sin enredar todo.&amp;#8221; Hermano, estás en la peor&amp;#8230; &amp;#8220;Los malos programadores removerán cielo y tierra para hacerlo mal.&amp;#8221; -Glenn Vanderburg.&lt;/p&gt;

&lt;p&gt;Pero lo que es realemente patético es que esas funcionalidades vienen en Java 8, incluyendo expresiones lambda y soporte de librerías incluyendo una interface Stream para precisamente permitir que este tipo de código sea escrito sin dolor. Esos programadores con los que Elliott está trabajando van a estar incluso más exitados por usar sus funcionalidades (y todas las ventajas asociadas por hacerlo, incluyendo composición y mucho más) en su código Java. Lo que puede hacer a Elliott más feliz es que al menos él no tendrá que haberlo escrito; va a estar escrito por personas más inteligentes que cualquiera.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h4 id=&#34;referencias&#34;&gt;Referencias&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;DZone&lt;/em&gt; »» &lt;a href=&#34;http://java.dzone.com/articles/functional-programming-java-%E2%80%93&#34; target=&#34;_blank&#34;&gt;On Functional Programming in Java – It&amp;rsquo;s Coming&amp;hellip;&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>