<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Sdl on El Baúl del programador</title>
        <link>https://elbauldelprogramador.com/tags/sdl/</link>
        <description>Recent content in Sdl on El Baúl del programador</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>es-ES</language>
        <lastBuildDate>Fri, 01 Jan 2016 00:00:00 +0000</lastBuildDate>
        <image>
            <url>https://elbauldelprogramador.com/img/bio-photo-rss.png</url>
            <link>https://elbauldelprogramador.com/tags/sdl/</link>
            <title>Sdl on El Baúl del programador</title>
            <width>144</width>
            <height>144</height>
        </image>
        <atom:link href="https://elbauldelprogramador.com/tags/sdl/" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Programación para Juegos - Lección 1 - Instalando SDL</title>
            <link>https://elbauldelprogramador.com/programacion-para-juegos-leccion-1/</link>
            <pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate>
            
            <guid>https://elbauldelprogramador.com/programacion-para-juegos-leccion-1/</guid>
            <description>&lt;p&gt;Como dije, voy a traducir el tutorial que estoy siguiendo de SDL, en &lt;a target=&#34;_blank&#34; href=&#34;http://www.lazyfoo.net/SDL_tutorials/&#34;&gt;Lazy Foo&amp;#8217; Productions&lt;/a&gt;, que se compone de 36 lecciones y el lenguaje que usa es C++, por ser considerado un estándar para la industria del juego.&lt;/p&gt;

&lt;p&gt;Esta primera parte de la lección 1 no la voy a traducir debido a que hay un gran abanico de posibilidades según el SO que tengáis y del IDE que queráis usar, los pasos son bastante sencillos y viene explicado con imágenes.&lt;/p&gt;

&lt;p&gt;&lt;!--ad--&gt;&lt;/p&gt;

&lt;p&gt;Selecciona el SO que tengas:&lt;/p&gt;

&lt;figure&gt;&lt;img sizes=&#34;(min-width: 128px) 128px, 100vw&#34; on=&#34;tap:lightbox1&#34; width=&#34;128&#34; height=&#34;128&#34; role=&#34;button&#34; tabindex=&#34;0&#34; layout=&#34;responsive&#34;  src=&#34;https://lh6.ggpht.com/_IlK2pNFFgGM/TSHH106Z0VI/AAAAAAAAAPo/fimALQz89iU/linux.png&#34;&gt;&lt;/img&gt;&lt;/figure&gt;
&lt;figure&gt;&lt;img sizes=&#34;(min-width: 128px) 128px, 100vw&#34; on=&#34;tap:lightbox1&#34; width=&#34;128&#34; height=&#34;128&#34; role=&#34;button&#34; tabindex=&#34;0&#34; layout=&#34;responsive&#34;  src=&#34;https://lh3.ggpht.com/_IlK2pNFFgGM/TSHJkwpqk-I/AAAAAAAAAP0/wSKqQWY0x_k/windows.png&#34;&gt;&lt;/img&gt;&lt;/figure&gt;
&lt;figure&gt;&lt;img sizes=&#34;(min-width: 128px) 128px, 100vw&#34; on=&#34;tap:lightbox1&#34; width=&#34;128&#34; height=&#34;128&#34; role=&#34;button&#34; tabindex=&#34;0&#34; layout=&#34;responsive&#34;  src=&#34;https://lh6.ggpht.com/_IlK2pNFFgGM/TSHH2DeE3mI/AAAAAAAAAPs/KES8kBZgn9M/apple-logo.png&#34;&gt;&lt;/img&gt;&lt;/figure&gt;

&lt;p&gt;Para los usuarios de GNU/Linux dejo el comando de instalación de las librerias:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sudo aptitude install libsdl1.2-dev libsdl-image1.2-dev libsdl-mixer1.2-dev libsdl-ttf2.0-dev&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Fuente: &lt;a href=&#34;http://www.lazyfoo.net/SDL_tutorials/&#34;&gt;lazyfoo.net&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;siguiente-tema-lección-1-2-hello-world-5&#34;&gt;Siguiente tema: &lt;a href=&#34;https://elbauldelprogramador.com/programacion-para-juegos-leccion-12/#more&#34;&gt;Lección 1.2 - Hello World&lt;/a&gt;&lt;/h1&gt;</description>
        </item>
        
        <item>
            <title>Programación para Juegos - Lección 1.2 - Hello World</title>
            <link>https://elbauldelprogramador.com/programacion-para-juegos-leccion-12/</link>
            <pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate>
            
            <guid>https://elbauldelprogramador.com/programacion-para-juegos-leccion-12/</guid>
            <description>&lt;p&gt;En esta lección vamos a aprender a hacer un Hola Mundo al estilo SDL.&lt;/p&gt;

&lt;p&gt;Ahora que ya &lt;a href=&#34;https://elbauldelprogramador.com/programacion-para-juegos-leccion-1/&#34;&gt;instalaste SDL&lt;/a&gt;, vamos a cargar una imagen en la pantalla.&lt;/p&gt;

&lt;p&gt;Empecemos:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.lazyfoo.net/downloads/index.php?file=SDLTut_lesson01&#34;&gt;Pueden descargar el código fuente de esta lección.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;!--ad--&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;//Include SDL functions and datatypes
#include &lt;span class=&#34;s2&#34;&gt;&amp;#34;SDL/SDL.h&amp;#34;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Al principio del código fuente incluimos el archivo de cabecera SDL, para poder usar funciones y tipos de datos de SDL.&lt;/p&gt;

&lt;p&gt;Los que están usando Visual Studio, deben incluir la cabecera así:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;#include &lt;span class=&#34;s2&#34;&gt;&amp;#34;SDL.h&amp;#34;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Si el compilador se queja diciendo que no puede encontrar &amp;#8220;SDL/SDL.h&amp;#8221;, es porque no tienen SDL instalado en el ruta(path) correcta.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;int main&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt; int argc, char* args&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    //The images
    SDL_Surface* &lt;span class=&#34;nv&#34;&gt;hello&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; NULL&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    SDL_Surface* &lt;span class=&#34;nv&#34;&gt;screen&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; NULL&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Al principio de la función main(), declaramos dos punteros a SDL_Surface. El tipo de dato SDL_Surface es una imagen, en esta aplicación vamos a tratar con dos imágenes. La superfície(Surface) &amp;#8220;hello&amp;#8221; es la imagen que vamos a cargar y mostrar. &amp;#8220;Screen&amp;#8221; es lo que es visible en la pantalla.&lt;/p&gt;

&lt;p&gt;Al estar tratando con punteros, debemos inicializarlos SIEMPRE.&lt;/p&gt;

&lt;p&gt;Cuando usemos SDL, la función main() debe estar declarada como la de arriba. No se puede usar void main() o cualquier otra cosa.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;//Start SDL
    SDL_Init&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt; SDL_INIT_EVERYTHING &lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

    //Set up screen
    &lt;span class=&#34;nv&#34;&gt;screen&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; SDL_SetVideoMode&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;640&lt;/span&gt;, &lt;span class=&#34;m&#34;&gt;480&lt;/span&gt;, &lt;span class=&#34;m&#34;&gt;32&lt;/span&gt;, SDL_SWSURFACE &lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

    //Load image
    &lt;span class=&#34;nv&#34;&gt;hello&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; SDL_LoadBMP&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;hello.bmp&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;La primera función a la que llamamos dentro de main() es SDL_Init(). Esta función inicializa todos los subsistemas de SDL para que podamos empezar a usar las funciones gráficas de SDL.&lt;/p&gt;

&lt;p&gt;Despues llamamos a SDL_SetVideoMode() para crear una ventana de 640&amp;#215;480 píxeles con 32-bits por pixel. El último argumento, SDL_SWSURFACE, establece la superficie en la memoria. Esta última función devuelve un puntero a la superficie de la ventana para que podamos usarlo.&lt;/p&gt;

&lt;p&gt;Después de establecer la ventana, cargamos nuestra imagen con SDL_LoadBMP(). Esta función recibe como argumento la ruta de una imagen bmp y devuelve un puntero a nuestra superficie &lt;var&gt;hello&lt;/var&gt;. Esta función devuelve NULL si ocurre algún error al cargar la imagen.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;//Apply image to screen
    SDL_BlitSurface&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt; hello, NULL, screen, NULL &lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

    //Update Screen
    SDL_Flip&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt; screen &lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

    //Pause
    SDL_Delay&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;2000&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ahora que tenemos nuestra ventana y nuestra imagen cargada, vamos a aplicar la imagen a la pantalla. Haremos esto con SDL_BlitSurface(). El primer argumento de SDL_BlitSurface() es la superficie fuente. El tercero la superficie destino. Esta función une la superficie fuente a la superficie destino. En este caso, vamos a aplicar nuestra imagen cargada a la pantalla. Encontrarás lo que hacen los otros argumentos en tutoriales posteriores.&lt;/p&gt;

&lt;p&gt;Ahora que ya está aplicada la imagen, hay que actualizar la pantalla para hacerla visible. Para ello llamamos a SDL_Flip(). Si no hacemos esto, solo se verá una pantalla blanca.&lt;/p&gt;

&lt;p&gt;Una vez hecho esto, lo siguiente es hacer que la ventana permanezca visible durante un tiempo en la pantalla. SDL_Delay() muestra la imagen en pantalla durante 2000 milisegundos (2 segundos). Aprenderemos una mejor manera de hacer esto en la &lt;a href=&#34;https://elbauldelprogramador.com/programacion-para-juegos-leccion-4/&#34;&gt;lección 4&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;//Free the loaded image
    SDL_FreeSurface&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt; hello &lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

    //Quit SDL
    SDL_Quit&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Como ya no vamos a usar mas la imagen cargada en nuestro programa, tenemos que eliminarla de la memoria. No se puede usar &lt;var&gt;delete&lt;/var&gt;, hay que usar SDL_FreeSurface() para eliminarla de memoria.&lt;/p&gt;

&lt;p&gt;Sin embargo, la superficie &lt;var&gt;screen&lt;/var&gt; no hay que borrarla a mano, ya que SDL_Quit() lo hace por nosotros.&lt;/p&gt;

&lt;p&gt;Enhorabuena, acabas de hacer tu primera aplicación gráfica.&lt;/p&gt;

&lt;p&gt;Fuente:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.lazyfoo.net/&#34;&gt;lazyfoo.net&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;siguiente-tema-lección-2-superficies-optimizadas-5&#34;&gt;Siguiente tema: &lt;a href=&#34;https://elbauldelprogramador.com/programacion-para-juegos-leccion-2/&#34;&gt;Lección 2 - Superficies Optimizadas&lt;/a&gt;&lt;/h1&gt;</description>
        </item>
        
        <item>
            <title>Programación para Juegos - Lección 2 - Imágenes Optimizadas</title>
            <link>https://elbauldelprogramador.com/programacion-para-juegos-leccion-2/</link>
            <pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate>
            
            <guid>https://elbauldelprogramador.com/programacion-para-juegos-leccion-2/</guid>
            <description>&lt;p&gt;&lt;a href=&#34;http://www.lazyfoo.net/downloads/index.php?file=SDLTut_lesson02&#34;&gt;Pueden descargar el código fuente de esta lección.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Ahora que ya hemos conseguido mostrar una imagen en pantalla en la &lt;a href=&#34;https://elbauldelprogramador.com/programacion-para-juegos-leccion-12/&#34;&gt;segunda parte de la lección 1&lt;/a&gt;, vamos a superponer varias imagenes de una manera más eficiente.&lt;/p&gt;

&lt;p&gt;&lt;!--ad--&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;//Cabeceras
&lt;span class=&#34;c1&#34;&gt;#include &amp;#34;SDL/SDL.h&amp;#34;
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;#include &amp;lt;string&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Estos son los archivos de cabecera para este programa.&lt;/p&gt;

&lt;p&gt;Incluimos SDL.h porque obviamente necesitamos funciones de SDL.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;//Atributos de la pantalla
const int &lt;span class=&#34;nv&#34;&gt;SCREEN_WIDTH&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;640&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
const int &lt;span class=&#34;nv&#34;&gt;SCREEN_HEIGHT&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;480&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
const int &lt;span class=&#34;nv&#34;&gt;SCREEN_BPP&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Aquí tenemos varios atributos de la pantalla.&lt;/p&gt;

&lt;p&gt;Es fácil averiguar para que sirven estos atributos, SCREEN_WIDTH para el ancho de la ventana, y SCREEN_HEIGHT para el alto. SCREEN_BPP son los bits por píxel que tendrá la imagen. Las imágenes que usamos son todas de 32-bit.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;//Superficies que vamos a usar
SDL_Surface *message &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; NULL&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
SDL_Surface *background &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; NULL&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
SDL_Surface *screen &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; NULL&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Estas son las tres imágenes que vamos a usar. &lt;code&gt;background&lt;/code&gt; obviamente es la imagen que se verá de fondo, &lt;code&gt;message&lt;/code&gt; es la imagen que dice &lt;code&gt;Hello&lt;/code&gt; y &lt;code&gt;screen&lt;/code&gt; es la ventana contenedora de las imágenes.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;SDL_Surface *load_image&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt; std::string filename &lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    //Temporary storage &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; the image that&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;s loaded
    SDL_Surface* &lt;span class=&#34;nv&#34;&gt;loadedImage&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; NULL&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

    //The optimized image that will be used
    SDL_Surface* &lt;span class=&#34;nv&#34;&gt;optimizedImage&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; NULL&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Esta función es la encargada de cargar la imagen.
Lo que hace es cargar la imagen y devolver un puntero a la versión optimizada de la imagen cargada.
El argumento &lt;code&gt;filename&lt;/code&gt; es la ruta de la imagen a cargar. &lt;code&gt;loadedImage&lt;/code&gt; es la superfície que obtenemos cuando la imagen se carga. &lt;code&gt;optimizedImage&lt;/code&gt; es la superfície que vamos a usar.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;//Cargamos la imagen
    &lt;span class=&#34;nv&#34;&gt;loadedImage&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; SDL_LoadBMP&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt; filename.c_str&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Lo primero es cargar la imagen usando SDL_LoadBMP().
Pero no se debe usar inmediatamente, ya que esta imagen es de 24-bit y &lt;code&gt;screen&lt;/code&gt; es de 32-bit. No es recomendable fusionar imagenes con diferente formato porque SDL tendrá que cambiar el formato en el aire (Durante la ejecución del programa), ralentizándolo.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;//Si nada va mal cargando la imagen
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt; loadedImage !&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; NULL &lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        //Create an optimized image
        &lt;span class=&#34;nv&#34;&gt;optimizedImage&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; SDL_DisplayFormat&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt; loadedImage &lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

        //Free the old image
        SDL_FreeSurface&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt; loadedImage &lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Lo siguiente es verificar que la imagen se ha cargado bien. Si ocurre algún error, loadedImage será NULL.&lt;/p&gt;

&lt;p&gt;Si la imagen se carga correctamente, llamamos a SDL_DisplayFormat() para que cree una nueva versión de &lt;code&gt;loadedImage&lt;/code&gt; en el mismo formato que &lt;code&gt;screen&lt;/code&gt;. La razón por la que hacemos esto es porque cuando intentamos &lt;code&gt;pegar&lt;/code&gt; una imagen en otra de diferente formato, SDL convierte la imagen, así que están en el mismo formato.&lt;/p&gt;

&lt;p&gt;Al crear la imagen convertida ganamos en velocidad de ejecución, ya que convertimos la imagen cuando la cargamos, de este modo al aplicar la imagen a &lt;code&gt;screen&lt;/code&gt;, ya está en el mismo formato. Por lo tanto SDL no tiene que convertirla en el aire.&lt;/p&gt;

&lt;p&gt;Así que ahora tenemos dos imágenes, la imagen cargada antigua (loadedImage), y la nueva imagen optimizada (optimizedImage).&lt;/p&gt;

&lt;figure&gt;
    &lt;img sizes=&#34;(min-width: 320px) 320px, 100vw&#34; on=&#34;tap:lightbox1&#34; role=&#34;button&#34; tabindex=&#34;0&#34; layout=&#34;responsive&#34;  height=&#34;240&#34; src=&#34;https://lh5.ggpht.com/_IlK2pNFFgGM/TT6GiUQZr0I/AAAAAAAAAQ4/bJGLBtK7gnE/displayformat.jpg&#34; width=&#34;320&#34;&gt;&lt;/img&gt;
&lt;/figure&gt;

&lt;p&gt;SDL_DisplayFormat() crea una imagen nueva optimizada pero no se deshace de la otra. Por eso hay que llamar a SDL_FreeSurface().&lt;/p&gt;

&lt;figure&gt;
    &lt;img sizes=&#34;(min-width: 320px) 320px, 100vw&#34; on=&#34;tap:lightbox1&#34; role=&#34;button&#34; tabindex=&#34;0&#34; layout=&#34;responsive&#34;  height=&#34;240&#34; src=&#34;https://lh6.ggpht.com/_IlK2pNFFgGM/TT6G2JAjz0I/AAAAAAAAAQ8/NtLIOitNd24/freesurface.jpg&#34; width=&#34;320&#34;&gt;&lt;/img&gt;
&lt;/figure&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; optimizedImage&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A continuación, la nueva versión optimizada de la imagen se devuelve.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;void apply_surface&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt; int x, int y, SDL_Surface* source, SDL_Surface* destination &lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    //Make a temporary rectangle to hold the offsets
    SDL_Rect offset&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

    //Give the offsets to the rectangle
    offset.x &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; x&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    offset.y &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; y&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Aquí tenemos nuestra función para fusionar las imágenes.
Como argumentos tiene las coordenadas donde queremos fusionar la imagen y las dos imágenes.
Primero creamos un objeto de tipo SDL_Rect. Hacemos esto porque SDL_BlitSurface() solo acepta este tipo de dato.
SDL_Rect es un tipo de dato que representa un rectángulo. Tiene cuatro miembros representando los valores X e Y de un rectángulo (Ancho y alto).&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;//Fusión de la imagen
    SDL_BlitSurface&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt; source, NULL, destination, &lt;span class=&#34;p&#34;&gt;&amp;amp;&lt;/span&gt;offset&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Con esto vamos a fusionar las imágenes.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;El primer argumento es la imagen que estamos usando.&lt;/li&gt;
&lt;li&gt;No os preocupéis por el segundo argumento, por ahora vamos a fijarlo a NULL.&lt;/li&gt;
&lt;li&gt;El tercer argumento es la imagen que vamos a fusionar.&lt;/li&gt;
&lt;li&gt;El cuarto argumento contiene la posición en la que se colocará la imagen una vez fusionada.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;int main&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt; int argc, char* args&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Empezamos con la función principal.&lt;/p&gt;

&lt;p&gt;Cuando usamos SDL, siempre hay que usar la función main de esta manera:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;argc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// o
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;argc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;**&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;//Inicializar todos los subsistemas
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt; SDL_Init&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt; SDL_INIT_EVERYTHING &lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; -1 &lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Usando SDL_Init() iniciamos SDL. A SDL_Init() le pasamos SDL_INIT_EVERYTHING, para que inicie cualquier subsistema de SDL. Los subsistemas SDL son cosas como video, audio, Temporizadores etc, que son componentes individuales usados para hacer juegos.&lt;/p&gt;

&lt;p&gt;No vamos a usar todos subsistemas, pero no pasa nada si los inicializamos.&lt;/p&gt;

&lt;p&gt;Si SDL no puede inicializarse, devuelve -1, en ese caso controlamos el error devolviendo 1, terminando el programa.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;//Configuramos la pantalla
    &lt;span class=&#34;nv&#34;&gt;screen&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; SDL_SetVideoMode&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt; SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_BPP, SDL_SWSURFACE &lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Creamos una ventana, lo que nos devuelve un puntero a la misma. Así podremos aplicar las imágenes a la ventana.&lt;/p&gt;

&lt;p&gt;Ya conocemos que son los tres primeros argumentos, el cuarto crea la ventana en memoria.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;//Si ocurre algún error
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;screen&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; NULL &lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Si hay algún error al crear la ventana, &lt;code&gt;screen&lt;/code&gt; será igual a NULL.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;//Título de la ventana
    SDL_WM_SetCaption&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Hello World&amp;#34;&lt;/span&gt;, NULL &lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Fijamos el título de la ventana a &lt;code&gt;Hello World&lt;/code&gt;. El segundo argumento es para indicar la ruta del icono de la ventana.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;//Cargamos las imágenes
    &lt;span class=&#34;nv&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; load_image&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;hello.bmp&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;nv&#34;&gt;background&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; load_image&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;background.bmp&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Cargamos las imágenes usando la función que creamos anteriormente.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;//Aplicamos el fondo a la ventana
    apply_surface&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;, background, screen &lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Aplicamos el fondo a la ventana con la función que hicimos. Antes de unir el fondo a la ventana, teníamos algo asi:&lt;/p&gt;

&lt;figure&gt;
    &lt;img sizes=&#34;(min-width: 320px) 320px, 100vw&#34; on=&#34;tap:lightbox1&#34; role=&#34;button&#34; tabindex=&#34;0&#34; layout=&#34;responsive&#34;  height=&#34;240&#34; width=&#34;320&#34; src=&#34;https://lh5.ggpht.com/_IlK2pNFFgGM/TT6HlvSgW8I/AAAAAAAAARE/TIY1ZDZZymM/blank.jpg&#34;&gt;&lt;/img&gt;
&lt;/figure&gt;

&lt;p&gt;Pero al unirlas, tendremos algo así:&lt;/p&gt;

&lt;figure&gt;
    &lt;img sizes=&#34;(min-width: 320px) 320px, 100vw&#34;  on=&#34;tap:lightbox1&#34; role=&#34;button&#34; tabindex=&#34;0&#34; layout=&#34;responsive&#34;  height=&#34;240&#34; width=&#34;320&#34; src=&#34;https://lh5.ggpht.com/_IlK2pNFFgGM/TT6Hlu7YxVI/AAAAAAAAARA/CzNfc3D0kso/background.jpg&#34;&gt;&lt;/img&gt;
&lt;/figure&gt;

&lt;p&gt;Cuando las unimos, se copian los píxels de una imagen a otra. Por eso el la imagen que estamos usando de fondo aparece en la esquina superior izquierda, queremos que el fondo ocupe toda la ventana, pero, ¿significa eso que tendremos que cargar la imagen de fondo 3 veces mas?&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;apply_surface&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;320&lt;/span&gt;, &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;, background, screen &lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
apply_surface&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;m&#34;&gt;240&lt;/span&gt;, background, screen &lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
apply_surface&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;320&lt;/span&gt;, &lt;span class=&#34;m&#34;&gt;240&lt;/span&gt;, background, screen &lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;No, lo que hacemos es fusionar la &lt;code&gt;misma&lt;/code&gt; imagen 3 veces mas.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;//Aplicando el mensaje a la ventana
apply_surface&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;180&lt;/span&gt;, &lt;span class=&#34;m&#34;&gt;140&lt;/span&gt;, message, screen &lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ahora vamos a aplicar la imagen mensaje a la ventana, en las coordenadas X=180 y Y=140&lt;/p&gt;

&lt;p&gt;El sistema de coordenadas de SDL no trabaja así:&lt;/p&gt;

&lt;figure&gt;
    &lt;img sizes=&#34;(min-width: 320px) 320px, 100vw&#34;  on=&#34;tap:lightbox1&#34; role=&#34;button&#34; tabindex=&#34;0&#34; layout=&#34;responsive&#34;  height=&#34;240&#34; width=&#34;320&#34; src=&#34;https://lh6.ggpht.com/_IlK2pNFFgGM/TT6HmFPv1EI/AAAAAAAAARI/ta-NTaunvQU/cartesian.jpg&#34;&gt;&lt;/img&gt;
&lt;/figure&gt;

&lt;p&gt;Trabaja así:&lt;/p&gt;

&lt;figure&gt;
    &lt;img sizes=&#34;(min-width: 320px) 320px, 100vw&#34;  on=&#34;tap:lightbox1&#34; role=&#34;button&#34; tabindex=&#34;0&#34; layout=&#34;responsive&#34;  height=&#34;240&#34; width=&#34;320&#34; src=&#34;https://lh6.ggpht.com/_IlK2pNFFgGM/TT6HmnGdBpI/AAAAAAAAARQ/QWA0K9-uB_A/sdlcoord.jpg&#34;&gt;&lt;/img&gt;
&lt;/figure&gt;

&lt;p&gt;El origen de coordenadas (0,0) está en la esquina superior izquierda. Por eso hay que aplicar la imagen de esta forma:&lt;/p&gt;

&lt;figure&gt;
    &lt;img sizes=&#34;(min-width: 320px) 320px, 100vw&#34;  on=&#34;tap:lightbox1&#34; role=&#34;button&#34; tabindex=&#34;0&#34; layout=&#34;responsive&#34;  height=&#34;240&#34; width=&#34;320&#34; src=&#34;https://lh4.ggpht.com/_IlK2pNFFgGM/TT6HmRzk0tI/AAAAAAAAARM/UoHjJY_0jxE/coorddemo.jpg&#34;&gt;&lt;/img&gt;
&lt;/figure&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;//Actualizando la pantalla
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt; SDL_Flip&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt; screen &lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; -1 &lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Como en la lección anterior, hay que actualizar la patalla para ver las imágenes. Si ocurre algún error devuelve -1, y nosotros devolvemos 1.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;//Esperamos &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt; seg
    SDL_Delay&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;2000&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Llamamos a esta función para que la ventana se muestre durante 2 segundos en pantalla.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;//Liberamos las imágenes
    SDL_FreeSurface&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt; message &lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    SDL_FreeSurface&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt; background &lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

    //Quit SDL
    SDL_Quit&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

    //Return
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ya que hemos terminado nuestro programa, usamos SDL_FreeSurface() para eliminar de memoria las variables que almacenaban las imágenes. Si no liberamos la memoria, estas variables se quedarán ocupando espacio.&lt;/p&gt;

&lt;p&gt;Fuente:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.lazyfoo.net/SDL_tutorials/&#34;&gt;lazyfoo.net&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;siguiente-tema-programación-para-juegos-lección-3-librerías-de-sdl-4&#34;&gt;Siguiente tema: &lt;a href=&#34;https://elbauldelprogramador.com/programacion-para-juegos-leccion-3/&#34;&gt;Programación para Juegos - Lección 3 Librerías de SDL&lt;/a&gt;&lt;/h1&gt;</description>
        </item>
        
        <item>
            <title>Programación para Juegos - Lección 3 - Librerías de SDL</title>
            <link>https://elbauldelprogramador.com/programacion-para-juegos-leccion-3/</link>
            <pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate>
            
            <guid>https://elbauldelprogramador.com/programacion-para-juegos-leccion-3/</guid>
            <description>&lt;p&gt;SDL nativamente solo soporta imágenes BMP, pero usando la libreria SDL_image, podremos cargar imagenes con extensión BMP, PNM, XPM, LBM, PCX, GIF, JPEG, TGA y PNG.&lt;/p&gt;

&lt;p&gt;Las librerías adicionales de SDL permiten usar funciones que SDL no soporta nativamente. Este tutorial enseñará a agregar estas librerías a nuestros programas.&lt;/p&gt;

&lt;p&gt;&lt;!--ad--&gt;&lt;/p&gt;

&lt;p&gt;Como en el primer turorial, &lt;a href=&#34;https://elbauldelprogramador.com/programacion-para-juegos-leccion-1/&#34;&gt;Programación para Juegos - Lección 1 - Instalando SDL&lt;/a&gt;, configurar las librerías adicionales de SDL depende de tu Sistema operativo y del IDE que uses. Así que dejo los enlaces para que sigáis unos pasos muy simples. Seleccionar vuestro Sistema Operatívo y depués el IDE que usáis.&lt;/p&gt;

&lt;figure&gt;
    &lt;a href=&#34;http://www.lazyfoo.net/SDL_tutorials/lesson03/linux/index.php&#34; target=&#34;_blank&#34;&gt;&lt;img sizes=&#34;(min-width: 128px) 128px, 100vw&#34; layout=&#34;responsive&#34; width=&#34;128&#34; height=&#34;128&#34; src=&#34;https://lh6.ggpht.com/_IlK2pNFFgGM/TSHH106Z0VI/AAAAAAAAAPo/fimALQz89iU/linux.png&#34;&gt;&lt;/img&gt;&lt;/a&gt;
    &lt;a href=&#34;http://www.lazyfoo.net/SDL_tutorials/lesson03/windows/index.php&#34; target=&#34;_blank&#34;&gt;&lt;img sizes=&#34;(min-width: 128px) 128px, 100vw&#34; layout=&#34;responsive&#34; width=&#34;128&#34; height=&#34;128&#34; src=&#34;https://lh3.ggpht.com/_IlK2pNFFgGM/TSHJkwpqk-I/AAAAAAAAAP0/wSKqQWY0x_k/windows.png&#34;&gt;&lt;/img&gt;&lt;/a&gt;
    &lt;a href=&#34;http://www.lazyfoo.net/SDL_tutorials/lesson03/mac/index.php&#34; target=&#34;_blank&#34;&gt;&lt;img sizes=&#34;(min-width: 128px) 128px, 100vw&#34; layout=&#34;responsive&#34; width=&#34;128&#34; height=&#34;128&#34; src=&#34;https://lh6.ggpht.com/_IlK2pNFFgGM/TSHH2DeE3mI/AAAAAAAAAPs/KES8kBZgn9M/apple-logo.png&#34;&gt;&lt;/img&gt;&lt;/a&gt;
&lt;/figure&gt;

&lt;p&gt;Fuente:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.lazyfoo.net/SDL_tutorials/&#34;&gt;lazyfoo.net&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;siguiente-tema-programación-para-juegos-lección-4-programación-orientada-a-eventos-6&#34;&gt;Siguiente tema: &lt;a href=&#34;https://elbauldelprogramador.com/programacion-para-juegos-leccion-4/&#34;&gt;Programación para Juegos - Lección 4 - Programación orientada a eventos&lt;/a&gt;&lt;/h1&gt;</description>
        </item>
        
        <item>
            <title>Programación para Juegos - Lección 5 - Colores Clave</title>
            <link>https://elbauldelprogramador.com/programacion-para-juegos-leccion-5/</link>
            <pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate>
            
            <guid>https://elbauldelprogramador.com/programacion-para-juegos-leccion-5/</guid>
            <description>&lt;p&gt;Lo que vamos a ver ahora son los &lt;em&gt;colores clave&lt;/em&gt;. Un color clave es un color que no queremos que aparezca en la imágen, como el fondo de la misma. La estructura &lt;code&gt;SDL_Surface&lt;/code&gt; tiene un elemento llamado &lt;em&gt;color key&lt;/em&gt; , que determina que color de la imagen no queremos que sea visible. Esto es lo que se usa cuando queremos una imagen con fondo transparente.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://lazyfoo.net/downloads/index.php?file=SDLTut_lesson05&#34;&gt;Pueden descargar el código fuente de esta lección.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Bien, supongamos que queremos fusionar esta imagen llamada &lt;em&gt;foo&lt;/em&gt;:&lt;/p&gt;

&lt;figure&gt;
    &lt;img sizes=&#34;(min-width: 32px) 32px, 100vw&#34; on=&#34;tap:lightbox1&#34; role=&#34;button&#34; tabindex=&#34;0&#34; layout=&#34;responsive&#34; alt=&#34;foo&#34;  height=&#34;64&#34; src=&#34;https://lh6.ggpht.com/_IlK2pNFFgGM/TT6FKpmp0fI/AAAAAAAAAQs/oFYGZsQzBn8/foo.jpg&#34; width=&#34;32&#34;&gt;&lt;/img&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;!--ad--&gt;&lt;/p&gt;

&lt;p&gt;a este fondo:&lt;/p&gt;

&lt;figure&gt;
    &lt;img sizes=&#34;(min-width: 320px) 320px, 100vw&#34; on=&#34;tap:lightbox1&#34; role=&#34;button&#34; tabindex=&#34;0&#34; layout=&#34;responsive&#34; alt=&#34;Imagen Fondo&#34;  height=&#34;240&#34; width=&#34;320&#34; src=&#34;https://lh4.ggpht.com/_IlK2pNFFgGM/TT6FKroPMYI/AAAAAAAAAQo/oJFPpVHNsIg/background.jpg&#34;&gt;&lt;/img&gt;
&lt;/figure&gt;

&lt;p&gt;Pero no queremos que aparezca el fondo azul claro de la primera imagen:&lt;/p&gt;

&lt;figure&gt;
    &lt;img sizes=&#34;(min-width: 320px) 320px, 100vw&#34; on=&#34;tap:lightbox1&#34; role=&#34;button&#34; tabindex=&#34;0&#34; layout=&#34;responsive&#34; alt=&#34;Resultado&#34;  height=&#34;240&#34; width=&#34;320&#34; src=&#34;https://lh4.ggpht.com/_IlK2pNFFgGM/TT6FLLUBg4I/AAAAAAAAAQ0/gS1QeS8p7PA/nokey.jpg&#34;&gt;&lt;/img&gt;
&lt;/figure&gt;

&lt;p&gt;Para que no se muestre el fondo de la primera imagen, necesitamos fijarlo como &lt;em&gt;color key&lt;/em&gt;, en este caso el valor de este color es (En hexadecimal): Red 0, Green FF, Blue FF.
El color key se suele fijar normalmente al cargar la imagen.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;n&#34;&gt;SDL_Surface&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;load_image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;filename&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;//The image that&amp;#39;s loaded
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;SDL_Surface&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;loadedImage&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;//The optimized image that will be used
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;SDL_Surface&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;optimizedImage&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;//Load the image
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;loadedImage&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;IMG_Load&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;filename&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c_str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;//If the image loaded
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;loadedImage&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;//Create an optimized image
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;optimizedImage&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SDL_DisplayFormat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;loadedImage&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

        &lt;span class=&#34;c1&#34;&gt;//Free the old image
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;SDL_FreeSurface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;loadedImage&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Esta es la función que carga la imagen, y que vamos a modificar.&lt;/p&gt;

&lt;p&gt;En primer lugar, cargamos la imagen optimizada, como hacíamos hasta ahora.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//If the image was optimized just fine
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;optimizedImage&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;//Map the color key
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;Uint32&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;colorkey&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SDL_MapRGB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;optimizedImage&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;format&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0xFF&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0xFF&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Comprobamos que la imagen fue optimizada.
Si todo va bien, necesitamos mapear el color que queremos ocultar. Llamamos a &lt;code&gt;SDL_MapRGB()&lt;/code&gt; para tomar los valores de rojo, verde y azul. Esta función nos devuelve el valor del pixel en el mismo formato que el de la imagen. Puedes leer más acerca de los pixeles en el &lt;a href=&#34;https://elbauldelprogramador.com/programacion-para-juegos-articulo-3-que/&#34;&gt;artículo 3&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//Set all pixels of color R 0, G 0xFF, B 0xFF to be transparent
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;SDL_SetColorKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;optimizedImage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SDL_SRCCOLORKEY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;colorkey&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ahora vamos a configurar el &lt;em&gt;color Key&lt;/em&gt;, lo que vamos a hacer es fijar todos los pixeles de color &lt;code&gt;00ffff&lt;/code&gt; a transparentes.
El primer argumento de esta función es la imagen para la cual queremos aplicar el &lt;em&gt;color key&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;El segundo es para los flags que desee aplicar, en este caso, el flag &lt;code&gt;SDL_SRCCOLORKEY&lt;/code&gt; asegura que estamos usando &lt;em&gt;color Key&lt;/em&gt; cuando fusionemos una imagen en otra.&lt;/p&gt;

&lt;p&gt;El tercero es el color que deseamos fijar como &lt;em&gt;color key&lt;/em&gt;, como vemos, es el color que hemos mapeado hace un momento.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//Return the optimized image
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;optimizedImage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Para finalizar, la función devuelve la imagen optimizada con el color clave.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//Apply the surfaces to the screen
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;apply_surface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;background&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;screen&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;apply_surface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;240&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;190&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;screen&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;//Update the screen
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SDL_Flip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;screen&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;El resultado de hacer todo esto da como resultado la imagen siguiente:&lt;/p&gt;

&lt;figure&gt;
    &lt;img sizes=&#34;(min-width: 320px) 320px, 100vw&#34; on=&#34;tap:lightbox1&#34; role=&#34;button&#34; tabindex=&#34;0&#34; layout=&#34;responsive&#34; alt=&#34;Imagen final&#34;  height=&#34;240&#34; width=&#34;320&#34; src=&#34;https://lh4.ggpht.com/_IlK2pNFFgGM/TT6FK_nKIkI/AAAAAAAAAQw/rDMnHtu9ewo/key.jpg&#34;&gt;&lt;/img&gt;
&lt;/figure&gt;

&lt;p&gt;Como vemos, ahora en la imagen del hombrecillo de Palo ya no se ve el fondo azul claro.&lt;/p&gt;

&lt;p&gt;Para aquellos que uséis imágenes PNGs con transparencia, &lt;code&gt;IMG_Load()&lt;/code&gt; la maneja automáticamente. Si itentamos fijar un color clave para imágenes que ya disponen de transparencia, ocasionaremos resultado extraños. También se perderá la transparencia Alfa si usamos &lt;code&gt;SDL_DisplayFormat()&lt;/code&gt; en lugar de &lt;code&gt;SDL_DisplayFormatAlpha()&lt;/code&gt;. Para mantener la transparencia en un PNG simplemente no fije un color clave. &lt;code&gt;IMG_Load()&lt;/code&gt; también se encarga del alfa de imágenes TGA. Busque en la documentación de SDL para obtener más información detallada sobre los colores clave.&lt;/p&gt;</description>
        </item>
        
        <item>
            <title>Programación para Juegos. Artículo 3. ¿Qué es un pixel?</title>
            <link>https://elbauldelprogramador.com/programacion-para-juegos-articulo-3-que/</link>
            <pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate>
            
            <guid>https://elbauldelprogramador.com/programacion-para-juegos-articulo-3-que/</guid>
            <description>&lt;p&gt;Este artículo hace referéncia a la &lt;a href=&#34;https://elbauldelprogramador.com/programacion-para-juegos-leccion-5/&#34;&gt;Lección 5 - Colores Clave&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;!--ad--&gt;&lt;/p&gt;

&lt;h1 id=&#34;qué-es-un-pixel&#34;&gt;¿Qué es un pixel?&lt;/h1&gt;

&lt;p&gt;Probablemente sepas que las imágenes están formadas por píxeles, pero, ¿Cómo se forman los píxeles?&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;//Map the color key
Uint32 &lt;span class=&#34;nv&#34;&gt;colorkey&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; SDL_MapRGB&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt; optimizedImage-&lt;span class=&#34;p&#34;&gt;&amp;amp;&lt;/span&gt;gt&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;format, &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;, 0xFF, 0xFF &lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Aquí tenemos una línea de código de la &lt;a href=&#34;https://elbauldelprogramador.com/programacion-para-juegos-leccion-5/&#34;&gt;Lección 5 - Colores Clave&lt;/a&gt;. Ya sabemos que &lt;code&gt;SDL_MapRGB()&lt;/code&gt; devuelve un pixel, pero ¿Cómo es la estructura &lt;code&gt;Uint32&lt;/code&gt; un píxel?&lt;/p&gt;

&lt;p&gt;&lt;!--more--&gt;&lt;!--ad--&gt;&lt;/p&gt;

&lt;p&gt;Bien, Uint32 es lo siguiente:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;U&lt;/strong&gt;nsigned &lt;strong&gt;int&lt;/strong&gt;eger, lo que son &lt;strong&gt;32&lt;/strong&gt; bits de tamaño.&lt;/p&gt;

&lt;p&gt;Os preguntaréis, ¿Cómo puede ser un número un píxel?, probablemente sepas algo de &lt;code&gt;HTML&lt;/code&gt;, y lo que hacemos en &lt;code&gt;HTML&lt;/code&gt; para cambiar los colores de los elementos es configurar el color combinando 3 números desde el 0 al 255.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;span&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;style&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;color: rgb(Red,Green,Blue)&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;Text&lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;span&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Arriba he usado el código &lt;code&gt;HTML&lt;/code&gt;/CSS para cambiar el color del texto. Combinando los valores Red, Green y Blue (Rojo, Verde y Azul) podemos obtener cualquier color. Por ejemplo:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;span&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;style&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;color: rgb(255,255,255)&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;Esto&lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;span&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; tiene Red 255, Green 255, y Blue 255.
&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;span&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;style&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;color: rgb(255,0,0)&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;Esto&lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;span&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; tiene Red 255, Green 0, y Blue 0.
&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;span&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;style&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;color: rgb(0,0,255)&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;Esto&lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;span&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; tiene Red 0, Green 0, y Blue 255.
&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;span&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;style&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;color: rgb(0,0,0)&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;Esto&lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;span&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; tiene Red , Green 0, y Blue 0.
&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;span&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;style&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;color: rgb(192,192,0)&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;Esto&lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;span&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; tiene Red 192, Green 192, y Blue 0.
&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;span&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;style&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;color: rgb(0,255,255)&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;Esto&lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;span&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; tiene Red 0, Green 255, y Blue 255.
&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;span&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;style&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;color: rgb(192,128,64)&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;Esto&lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;span&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; tiene Red 192, Green 128, y Blue 64.
&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;span&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;style&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;color: rgb(186,3,207)&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;Esto&lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;span&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; tiene Red 186, Green 3, y Blue 207.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Dicho esto, una estructura Uint32 es tan solo un número. ¿Si los píxeles están hechos por un conjunto de numeros, no deberían ser un array?&lt;/p&gt;

&lt;p&gt;En realidad, lo es.&lt;/p&gt;

&lt;p&gt;Los valores red, green y blue que crean un píxel pueden ser un número del 0 al 255. Recuerda que el 0 también es un número y en programación siempre empezamos a contar desde el 0. Eso significa que tenemos 256 posíbles valores. 256 es 2&lt;sup&gt;8&lt;/sup&gt;, lo que significa que cada uno de los valores que componen el color se puede representar con 8 bits.&lt;/p&gt;

&lt;p&gt;Un &lt;code&gt;Uint32&lt;/code&gt; es simplemente cada uno de esos 8 bits juntos uno detrás de otro en el mismo número. En la memoria del ordenador los píxeles en esencia son así.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;span&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;style&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;color: rgb(255,0,0)&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;10101011&lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;span&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;span&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;style&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;color: rgb(0,255,0)&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;00101011&lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;span&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;span&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;style&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;color: rgb(0,0,255)&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;01011011&lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;span&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Puesto que es sólo una serie de números de 8 bits, todo lo que hay que hacer para conseguir colores individuales es hacer un &lt;em&gt;casting&lt;/em&gt; al número de 32 bits.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;//Obtenemos la dirección de memoria del píxel
Uint8 *colors &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;Uint8*&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;amp;&lt;/span&gt;pixel&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

//Obtenemos los colores individuales
&lt;span class=&#34;nv&#34;&gt;red&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; colors&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;nv&#34;&gt;green&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; colors&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;nv&#34;&gt;blue&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; colors&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Por lo general nunca necesitarás hacer esto. Para obtener los colores individuales de un píxel se debe usar &lt;code&gt;SDL_GetRGB()&lt;/code&gt;. Explicaré porqué:&lt;/p&gt;

&lt;p&gt;Probablemente estarás pensando que hay un error. 8 bits por color * 3 colores = 24 bits. ¿Qué pasa con los otros 8 bits?, los 8 bits restantes son los que se usan para el canal alfa del píxel.&lt;/p&gt;

&lt;p&gt;El alfa controla la transparencia del píxel. El valor 255 para el alfa quiere decir que el píxel es completamente opaco y 0 completamente transparente. A continuación hay unos ejemplos de una imagen sobre un fondo blanco. Cada imagen tiene un valor para el alfa distinto:&lt;/p&gt;

&lt;figure&gt;
    &lt;img sizes=&#34;(min-width: 320px) 320px, 100vw&#34; on=&#34;tap:lightbox1&#34; role=&#34;button&#34; tabindex=&#34;0&#34; layout=&#34;responsive&#34;  height=&#34;240&#34; width=&#34;320&#34; src=&#34;https://2.bp.blogspot.com/_IlK2pNFFgGM/TUK2lKrtn2I/AAAAAAAAASs/vVyJ2YkO3oY/s320/255.jpg&#34;&gt;&lt;/img&gt;
    &lt;figcaption&gt;En esta imagen el alfa esta a 255.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;figure&gt;
  &lt;img sizes=&#34;(min-width: 320px) 320px, 100vw&#34; on=&#34;tap:lightbox1&#34; role=&#34;button&#34; tabindex=&#34;0&#34; layout=&#34;responsive&#34;  height=&#34;240&#34; width=&#34;320&#34; src=&#34;https://1.bp.blogspot.com/_IlK2pNFFgGM/TUK2lEXQZAI/AAAAAAAAAS0/kyR_W-tWVo0/s320/192.jpg&#34;&gt;&lt;/img&gt;
  &lt;figcaption&gt;En esta imagen el alfa esta a 192. Se puede ver como el fondo blanco empieza a mostrarse a través de la imagen.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;figure&gt;
  &lt;img sizes=&#34;(min-width: 320px) 320px, 100vw&#34; on=&#34;tap:lightbox1&#34; role=&#34;button&#34; tabindex=&#34;0&#34; layout=&#34;responsive&#34;  height=&#34;240&#34; width=&#34;320&#34; src=&#34;https://2.bp.blogspot.com/_IlK2pNFFgGM/TUK2lWOQFWI/AAAAAAAAAS8/R3cn8kuccy0/s320/128.jpg&#34;&gt;&lt;/img&gt;
  &lt;figcaption&gt;En esta imagen el alfa esta a 128. Aproximadamente el 50% de transparencia.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;figure&gt;
    &lt;img sizes=&#34;(min-width: 320px) 320px, 100vw&#34; on=&#34;tap:lightbox1&#34; role=&#34;button&#34; tabindex=&#34;0&#34; layout=&#34;responsive&#34;  height=&#34;240&#34; width=&#34;320&#34; src=&#34;https://4.bp.blogspot.com/_IlK2pNFFgGM/TUK2luEZy5I/AAAAAAAAATE/pa2iI4pX_Pk/s320/0.jpg&#34;&gt;&lt;/img&gt;
  &lt;figcaption&gt;En esta imagen el alfa esta a 0. Completamente transparente.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Asi que así es como un píxel de 32 bit &lt;code&gt;RGBA&lt;/code&gt; está hecho.&lt;/p&gt;

&lt;p&gt;Hay diferentes formatos de píxeles. Los colores pueden ir en distinto orden, como &lt;code&gt;BGRA&lt;/code&gt; (Blue, Green, Red y Alfa.). &lt;code&gt;ABGR&lt;/code&gt; es más o menos lo mismo pero con el alfa en primer lugar. Los píxeles también pueden tener distintos tamaños, como los bitmap (24 bit BGR). También los hay de 16 bit, que almacenan los valores así: 5 bits para el Rojo, 5 para el verde, 5 para el azul y 1 para el alfa.&lt;/p&gt;

&lt;p&gt;Hay muchos formatos más, pero no vamos a entrar en detalle. Al tener todos estos formatos de pixel lo que hay que hacer es pasar un &lt;code&gt;SDL_PixelFormat&lt;/code&gt; a &lt;code&gt;SDL_MapRGB()&lt;/code&gt; y &lt;code&gt;SDL_GetRGB()&lt;/code&gt; ya que las funciones saben cómo trabajar con los píxeles.&lt;/p&gt;

&lt;p&gt;Los distintos formatos de imágenes son la razón por la que no podemos fusionar imagenes que sean de distinto formato. Si se copia un píxel &lt;code&gt;ABGR&lt;/code&gt; en una imagen con formato &lt;code&gt;RGBA&lt;/code&gt; los colores estarán todos mal. SDL puede convertir los píxeles en &lt;em&gt;el aire&lt;/em&gt;, pero esto consume mucha CPU. Por eso en todas las lecciones convertimos las imágenes al formato de la pantalla cuando las cargamos en nuestra función &lt;code&gt;load_image()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Hay mucho más que hablar sobre los píxeles, por ejemplo como funciona la conversión de píxeles, pero es algo de lo que no hay que preocuparse a no ser que se trabaje a muy bajo nivel. Por ahora ya conoce todo lo básico acerca de las imágenes.&lt;/p&gt;

&lt;p&gt;Como reflexión, ya que todos los píxeles RGB son combinaciones de 3 números, ¿No sería posible contar todos ellos para mostrar todas las combinaciones posibles?. Y si las imágenes son combinaciones de píxeles, ¿No sería posible contar cada combinación posible de píxeles y mostrar todas las imágenes posibles que podrías existir?&lt;/p&gt;

&lt;p&gt;Eso estaria bien, ¿no? =)&lt;/p&gt;</description>
        </item>
        
        <item>
            <title>Programación para Juegos. Lección 4 . Programación orientada a eventos</title>
            <link>https://elbauldelprogramador.com/programacion-para-juegos-leccion-4/</link>
            <pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate>
            
            <guid>https://elbauldelprogramador.com/programacion-para-juegos-leccion-4/</guid>
            <description>&lt;p&gt;&lt;a href=&#34;http://www.lazyfoo.net/downloads/index.php?file=SDLTut_lesson04&#34;&gt;Pueden descargar el código fuente de esta lección.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;En este tutorial veremos como capturar y manejar eventos.&lt;/p&gt;

&lt;p&gt;Un evento es simplemete algo que pasa. Como presionar una tecla, mover el ratón, redimensionar la ventana o cuando el usuario quiere cerrar la ventana.&lt;/p&gt;

&lt;p&gt;&lt;!--ad--&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//The headers
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;#34;SDL/SDL.h&amp;#34;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;#34;SDL/SDL_image.h&amp;#34;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;//Screen attributes
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SCREEN_WIDTH&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;640&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SCREEN_HEIGHT&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;480&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SCREEN_BPP&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;//The surfaces
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SDL_Surface&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;image&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;SDL_Surface&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;screen&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Arriba tenemos lo que hemos ido aprendiendo hasta ahora, las cabeceras, constantes e imágenes.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//Variable de tipo evento, para posteriormente manejarlo.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SDL_Event&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Una estructura SDL_Event almacena los datos del evento para que lo manejemos.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;n&#34;&gt;SDL_Surface&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;load_image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;filename&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;//The image that&amp;#39;s loaded
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;SDL_Surface&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;loadedImage&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;//The optimized image that will be used
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;SDL_Surface&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;optimizedImage&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;//Load the image
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;loadedImage&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;IMG_Load&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;filename&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c_str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;//If the image loaded
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;loadedImage&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;//Create an optimized image
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;optimizedImage&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SDL_DisplayFormat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;loadedImage&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

        &lt;span class=&#34;c1&#34;&gt;//Free the old image
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;SDL_FreeSurface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;loadedImage&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;//Return the optimized image
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;optimizedImage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;apply_surface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SDL_Surface&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;source&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SDL_Surface&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;destination&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;//Temporary rectangle to hold the offsets
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;SDL_Rect&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;offset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;//Get the offsets
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;offset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;offset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;//Blit the surface
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;SDL_BlitSurface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;source&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;destination&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;offset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Nuestras funciones para cargar y fusionar las imágenes, no ha cambiado nada con respecto al &lt;a href=&#34;https://elbauldelprogramador.com/programacion-para-juegos-leccion-2/&#34;&gt;tutorial 2&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;init&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;//Initialize all SDL subsystems
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SDL_Init&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SDL_INIT_EVERYTHING&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;//Set up the screen
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;screen&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SDL_SetVideoMode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SCREEN_WIDTH&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SCREEN_HEIGHT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SCREEN_BPP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SDL_SWSURFACE&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;//If there was an error in setting up the screen
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;screen&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;//Set the window caption
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;SDL_WM_SetCaption&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Event test&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;//If everything initialized fine
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;La función de inicialización, que inicializa SDL, configura la ventana fijando un título para la misma y devuelve false si ocurre algún error.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;load_files&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;//Load the image
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;image&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;load_image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;x.png&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;//If there was an error in loading the image
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;image&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;//If everything loaded fine
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Función para cargar la imagen. Devuelve false si ocurre algún error.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;clean_up&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;//Free the image
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;SDL_FreeSurface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;image&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;//Quit SDL
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;SDL_Quit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Función para borrar los datos de la memoria al terminar el programa.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;argc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;//Make sure the program waits for a quit
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;quit&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ésta es la función principal, donde creamos la variable que nos dirá cuando quiere el usuario cerrar la ventana. Al iniciar el programa, lógicamente la igualamos a false, ya que de lo contrario el programa finalizaría inmediatamente.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//Initialize
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;init&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;//Load the files
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;load_files&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Llamamos a las funciones de inicialización y carga de imágenes que definimos anteriormente.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//Apply the surface to the screen
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;apply_surface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;screen&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;//Update the screen
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SDL_Flip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;screen&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Con éste fragmento de código mostramos la imágen en pantalla.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//While the user hasn&amp;#39;t quit
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;quit&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Comenzamos el bucle principal, el cual seguirá funcionando hasta que el usuario fije la variable &lt;var&gt;quit&lt;/var&gt; a true.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//While there&amp;#39;s an event to handle
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SDL_PollEvent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;En SDL cuando ocurre un evento, se coloca en la cola de eventos. Ésta cola de eventos contiene los datos de los eventos para cada evento que sucede.
Por ejemplo si fuera a presionar un botón del ratón, mover el cursor y a continuación, presionar una tecla del teclado, la cola de eventos se vería así:&lt;/p&gt;

&lt;figure&gt;
    &lt;img sizes=&#34;(min-width: 255px) 255px, 100vw&#34; on=&#34;tap:lightbox1&#34; role=&#34;button&#34; tabindex=&#34;0&#34; layout=&#34;responsive&#34;  height=&#34;177&#34; width=&#34;255&#34; src=&#34;https://lh3.ggpht.com/_IlK2pNFFgGM/TT6ImYP7bjI/AAAAAAAAARU/QiAey3O_FW0/queue.jpg&#34;&gt;&lt;/img&gt;
&lt;/figure&gt;

&lt;p&gt;Lo que &lt;code&gt;SDL_PollEvent()&lt;/code&gt; hace es sacar un evento de la cola y guardar sus datos en nuestra estructura de tipo Evento:&lt;/p&gt;

&lt;figure&gt;
    &lt;img sizes=&#34;(min-width: 294px) 294px, 100vw&#34; on=&#34;tap:lightbox1&#34; role=&#34;button&#34; tabindex=&#34;0&#34; layout=&#34;responsive&#34;  height=&#34;258&#34; width=&#34;294&#34; src=&#34;https://lh5.ggpht.com/_IlK2pNFFgGM/TT6ImqKAdJI/AAAAAAAAARY/JqvFGavqRHY/poll.jpg&#34;&gt;&lt;/img&gt;
&lt;/figure&gt;

&lt;p&gt;Por lo tanto este código es recoger datos de los eventos &lt;strong&gt;mientras&lt;/strong&gt; haya en la cola.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//If the user has Xed out the window
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SDL_QUIT&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;c1&#34;&gt;//Quit the program
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;n&#34;&gt;quit&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Cuando el usuario clica en la &lt;strong&gt;X&lt;/strong&gt; de la ventana, el tipo de evento que se genera es &lt;code&gt;SDL_QUIT&lt;/code&gt;. Pero al hacer esto no implica que el programa termine, todo lo que hace este evento es informarnos que el usuario quiere salir del programa.
Ahora que sabemos que el usuario quiere finalizar la ejecución del programa, asignamos el valor &lt;var&gt;true&lt;/var&gt; a la variable &lt;var&gt;quit&lt;/var&gt;, lo que romperá la ejecución del bucle &lt;var&gt;while&lt;/var&gt; en el que nos encontramos.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//Free the surface and quit SDL
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;clean_up&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;

    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Finalmente, llamamos a nuestra función clean_up() para que elimine las variables creadas por SDL.&lt;/p&gt;

&lt;p&gt;Hay otras maneras de controlar eventos como SDL_WaitEvent() y SDL_PeepEvents(). Se puede encontrar más información sobre esto en la documentación de SDL.&lt;/p&gt;

&lt;p&gt;Fuente:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.lazyfoo.net/SDL_tutorials/&#34;&gt;lazyfoo.net&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;siguiente-tema-lección-5-colores-clave-4&#34;&gt;Siguiente tema: &lt;a href=&#34;https://elbauldelprogramador.com/programacion-para-juegos-leccion-5/&#34;&gt;Lección 5 - Colores Clave&lt;/a&gt;&lt;/h1&gt;</description>
        </item>
        
    </channel>
</rss>
